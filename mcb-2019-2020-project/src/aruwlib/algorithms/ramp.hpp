#ifndef RAMP_HPP_
#define RAMP_HPP_

#include <stdint.h>

namespace aruwlib
{
namespace algorithms
{
/**
 * An output value is incremented or decremented at every call to update
 * until target has been reached.
 *
 * This is very similar to modm's ramp except for one difference: rather than
 * setting the increment at the beginning, you set the increment each time,
 * which allows you to take into account systems where time increment is not
 * constant.
 */
class Ramp
{
public:
    /**
     * Create a ramp generator.
     *
     * @param initialValue The starting value
     */
    explicit Ramp(const float& initialValue = 0.0f);

    ///< Sets a new target ramp value.
    void setTarget(const float& target);

    /**
     * Updates the ramp by incrementing or decrementing the target
     * by the increment
     *
     * @note for expected results, call this function every controller
     *      iteration.
     * @note the increment should be based on the time<br>
     *      for example, if you are ramping a motor angle and
     *      want a motor to turn at some
     *      <code>rotationSpeed</code> pass in the following:
     *      <code>(currtime - prevtime) * rotationSpeed</code>
     */
    void update(float increment);

    ///< Returns the current value being generated by the ramp.
    const float& getValue() const;

    ///< Returns true if the value == target.
    bool isTargetReached() const;

    ///< Returns the target value (where the ramp generator will head torwards).
    const float& getTarget() const;

private:
    static constexpr float RAMP_EPSILON = 0.00000000001f;
    float target;        ///< The value's end goal.
    float value;         ///< The value to be incremented towards the target.
    bool targetReached;  ///< Whether or not target and value have converged.
};                       // class Ramp

}  // namespace algorithms

}  // namespace aruwlib

#endif  // RAMP_HPP_
