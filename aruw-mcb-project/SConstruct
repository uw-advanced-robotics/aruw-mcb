# Copyright (c) 2020-2021 Advanced Robotics at the University of Washington <robomstr@uw.edu>
#
# This file is part of aruw-mcb.
#
# aruw-mcb is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# aruw-mcb is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with aruw-mcb.  If not, see <https://www.gnu.org/licenses/>.

import os
import sys
import platform

from os.path import join, abspath

from SCons.Script import *

from build_tools import parse_args, extract_robot_type


# Define project settings and build paths
PROJECT_NAME         = "aruw-mcb"
BUILD_PATH           = "build"
HARDWARE_MODM_PATH   = "taproot/modm"
SIM_MODM_PARENT_PATH = "taproot/sim-modm/"
TAPROOT_SRC_PATH     = "taproot/src"
TAPROOT_TEST_PATH    = "taproot/test"
TAPROOT_PATH         = join(TAPROOT_SRC_PATH, "tap")
LINKERSCRIPT_FILE    = join(HARDWARE_MODM_PATH, "link/linkerscript.ld")
SRC_PATH             = "src"
TEST_PATH            = "test"

# Define libraries
HOSTED_LIBS          = ["pthread"]
GTEST_LIBS           = ["gtest", "gtest_main", "gmock", "gmock_main"]
COVERAGE_LIBS        = ["-lgcov"]


# Parse and validate arguments
args = parse_args.parse_args()

def _get_hosted_target_name_for_current_platform():
    os_type = platform.system()
    try:
        return {
            "Windows": "hosted-windows",
            "Darwin": "hosted-darwin",
            "Linux": "hosted-linux",
        }[os_type]
    except KeyError:
        raise ValueError(f"Unknown host OS {os_type}")

def _get_sim_modm_instance_path():
    return f"taproot/sim-modm/{_get_hosted_target_name_for_current_platform()}/modm"

# Set up target environment-specific paths
if args["TARGET_ENV"] == "tests":
    modm_path = _get_sim_modm_instance_path()
elif args["TARGET_ENV"] == "sim":
    modm_path = _get_sim_modm_instance_path()
elif args["TARGET_ENV"] == "hardware":
    modm_path = HARDWARE_MODM_PATH


# Set the number of threads unless it has already been set to anything but 1
if GetOption("num_jobs") == 1:
    SetOption("num_jobs", 8)


# Define a new SCons environment and set up basic build variables
env = DefaultEnvironment(ENV=os.environ)
env["CONFIG_BUILD_BASE"] = abspath(join(BUILD_PATH, args["TARGET_ENV"]))
env["CONFIG_PROJECT_NAME"] = PROJECT_NAME
env["CONFIG_ARTIFACT_PATH"] = join(env["CONFIG_BUILD_BASE"], "artifact")
env["CONFIG_PROFILE"] = args["BUILD_PROFILE"]

if sys.platform == "win32":
    # Workaround for "The command line is too long" error from Windows' libc when executing a long
    # command.
    # Adapted from: https://github.com/SCons/scons/wiki/LongCmdLinesOnWin32

    import subprocess
    def win32_spawn_via_popen(_sh, _escape, cmd, args, env):
        # Blind argument concatenation is generally dangerous but args seem to already come in
        # escaped+quoted.
        # "args" is intended to be the target's argv, and thus the first entry is the program name
        # itself. We strip this and replace it with the explicit target command before passing it to
        # Popen. Windows will internally compute an appropriate argv.
        concatenated_args = " ".join(args[1:])
        command_with_args = cmd + " " + concatenated_args

        # Provided shell and escape function are ignored. It is not clear under what cases scons
        # uses the features of a host shell so it's unused for simplicity.

        proc = subprocess.Popen(
            command_with_args,
            stdin = None,
            stdout = None,
            stderr = None,
            shell = False,
            env = env
        )
        _stdout, _stderr = proc.communicate()
        status_code = proc.wait()
        return status_code

    env['SPAWN'] = win32_spawn_via_popen

print("Configured {0} parallel build jobs (-j{0}), {1}"
    .format(GetOption("num_jobs"), args["ROBOT_TYPE"]))


# Building all libraries (read from sconscript files located in provided dirs)
# Ensure that modm is first, since Taproot depends on modm
external_scons_libraries = [modm_path, TAPROOT_PATH]
env.SConscript(dirs=external_scons_libraries, exports="env")

# References:
#   GCC flags: https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html
#   Scons API: https://www.scons.org/doc/latest/HTML/scons-user/apa.html
# 
# You can append one or multiple options like this
#     env.Append(CCFLAGS="-pedantic")
#     env.Append(CCFLAGS=["-pedantic", "-pedantic-errors"])
# If you need to remove options, you need to do this:
#     env["CCFLAGS"].remove("-pedantic")
# Note that a lot of options also have a "-no-{option}" option
# that may overwrite previous options.

# Add source directory to build path (for including header files)
env.AppendUnique(CPPPATH=[
    abspath(TAPROOT_SRC_PATH),
    abspath(TAPROOT_TEST_PATH),
    abspath(r"./src")
])

# Add build-specific flags
if args["BUILD_PROFILE"] == "debug":
    env.AppendUnique(CCFLAGS=["-fno-inline"])
elif args["BUILD_PROFILE"] == "fast":
    if "-g3" in env["CCFLAGS"]:
        env["CCFLAGS"].remove("-g3")
    env.AppendUnique(CCFLAGS=["-O0"])
elif args["BUILD_PROFILE"] == "release":
    # Replace -Os with -O3
    if "-Os" in env["CCFLAGS"]:
        env["CCFLAGS"].remove("-Os")
    env.AppendUnique(CCFLAGS=["-O2"])

# Add profiling-specific flags
if args["PROFILING"] == "true":
    env.AppendUnique(CPPFLAGS=["-DRUN_WITH_PROFILING"])

# Add target-specific flags
if args["TARGET_ENV"] == "sim":
    env.AppendUnique(CPPFLAGS=["-DPLATFORM_HOSTED"])
    env.AppendUnique(LIBS=HOSTED_LIBS)
elif args["TARGET_ENV"] == "tests":
    env.AppendUnique(CPPFLAGS=[
        "-DPLATFORM_HOSTED",
        "-DENV_UNIT_TESTS"])
    env.AppendUnique(CPPPATH=[abspath(TAPROOT_TEST_PATH)])
    env.AppendUnique(CPPPATH=[abspath(TEST_PATH)])
    env.AppendUnique(LIBS=GTEST_LIBS)
    env.AppendUnique(LIBS=HOSTED_LIBS)

    # Add flags necessary for coverage
    if COMMAND_LINE_TARGETS[0] == "run-tests-gcov":
        env.AppendUnique(CPPFLAGS=[
            "-fprofile-arcs",
            "-ftest-coverage"])
        env.AppendUnique(LIBS=COVERAGE_LIBS)
else:  # hardware target env
    # Update linkerscript file
    env["LINKFLAGS"].remove("-Tmodm/link/linkerscript.ld")
    env.AppendUnique(LINKFLAGS=["-T" + LINKERSCRIPT_FILE])


# Add any additional flags the user chooses specify
if "additional-ccflags" in ARGUMENTS:
    env.AppendUnique(CCFLAGS=[*ARGUMENTS["additional-ccflags"].split(",")])


# Find Taproot test source files if necessary
if args["TARGET_ENV"] == "tests":
    sources = env.FindSourceFiles(TAPROOT_TEST_PATH)
else:
    sources = []


# Use an SConscript file in the source directory to enable building with
# source-specific build flags (e.g. robot type)
env.SConscript(dirs=[SRC_PATH, TEST_PATH], exports=["env", "args", "sources"])


if args["COMPILE_SRC"]:
    # Only add aliases when we are compiling source. When we don't add alias, the default
    # build environment will only build the static libraries (modm and Taproot)
    if args["TARGET_ENV"] == "hardware":
        program = env.Program(target=env["CONFIG_PROJECT_NAME"]+".elf", source=sources)

        # The executable depends on the linkerscript
        env.Depends(target=program, dependency=abspath("taproot/modm/link/linkerscript.ld"))

        # Add target environment-specific SCons aliases
        # WARNING: all aliases must be checked during argument validation
        env.Alias("build", program)
        env.Alias("size", env.Size(program))
        env.Alias("gdb", env.DebugGdbRemote(program))
        env.Alias("run", [env.ProgramOpenOcd(program)])
        env.Alias("all", ["build", "size"])
        env.Default("all")  # For the hardware target env, "all" runs if you don't
                            # specify anything (i.e. just type "scons")
    elif args["TARGET_ENV"] == "tests":
        env.Append(toolpath=[abspath(r"../taproot-scripts/scons-tools")])
        env.Tool("run_gcov")

        program = env.Program(target=env["CONFIG_PROJECT_NAME"]+"-tests.elf", source=sources)

        # Add target environment-specific SCons aliases
        # WARNING: all aliases must be checked during argument validation
        env.Alias("build-tests", program)
        env.Alias("run-tests", env.Run(program))
        env.Alias("run-tests-gcov", [env.RunGCOV(program, False, [])])
    else:
        program = env.Program(target=env["CONFIG_PROJECT_NAME"]+".elf", source=sources)

        # Add target environment-specific SCons aliases
        # WARNING: all aliases must be checked during argument validation
        env.Alias("build-sim", program)
        env.Alias("run-sim", env.Run(program))
